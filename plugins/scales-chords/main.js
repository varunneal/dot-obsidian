/*
THIS IS A GENERATED/BUNDLED FILE BY ROLLUP
if you want to view the source visit the plugins github repository
*/

'use strict';

var obsidian = require('obsidian');

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

const DEFAULT_SETTINGS = {
    instrument: 'piano'
};
class ScalesChordsPlugin extends obsidian.Plugin {
    onload() {
        return __awaiter(this, void 0, void 0, function* () {
            console.log('loading ScalesChords');
            //@ts-ignore
            window.scales_chords_api_debug = true;
            yield this.loadSettings();
            this.addSettingTab(new SettingTab(this.app, this));
            this.registerMarkdownCodeBlockProcessor("tab", (source, el, ctx) => {
                let chords = new Set();
                let pre = document.createElement("pre");
                let lines = source.split("\n");
                for (var line of lines) {
                    // parse tab lines out into separate tokens, preserving white space
                    if (line[line.length - 1] == "%") {
                        let tokens = [];
                        var cur_token = '';
                        var last_char = '';
                        for (var char of line.split("")) {
                            if (char == "%")
                                char = " ";
                            if ((last_char == ' ' && char != ' ') || (last_char != ' ' && char == ' ')) {
                                tokens.push(cur_token);
                                cur_token = '';
                            }
                            cur_token += char;
                            last_char = char;
                        }
                        tokens.push(cur_token);
                        let div = document.createElement('div');
                        for (var token of tokens) {
                            if (token[0] != ' ') {
                                chords.add(token);
                                let e = document.createElement('b');
                                e.innerHTML = token;
                                let _token = token;
                                this.registerDomEvent(e, 'click', (evt) => {
                                    new TabModal(this.app, _token, this.settings.instrument).open();
                                });
                                div.appendChild(e);
                            }
                            else {
                                div.appendChild(document.createTextNode(token));
                            }
                        }
                        pre.appendChild(div);
                    }
                    else {
                        let line_elem = document.createTextNode(line + "\n");
                        pre.appendChild(line_elem);
                    }
                }
                el.appendChild(pre);
                for (var chord of chords) {
                    if (chord == '')
                        continue;
                    append_chord_image(el, chord, this.settings.instrument);
                }
            });
        });
    }
    onunload() {
        console.log('unloading plugin');
    }
    loadSettings() {
        return __awaiter(this, void 0, void 0, function* () {
            this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
        });
    }
    saveSettings() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.saveData(this.settings);
        });
    }
}
class TabModal extends obsidian.Modal {
    constructor(app, _chord, _instrument) {
        super(app);
        this.instrument = _instrument;
        this.chord = _chord;
    }
    onOpen() {
        let { contentEl } = this;
        append_chord_image(contentEl, this.chord, this.instrument);
    }
    onClose() {
        let { contentEl } = this;
        contentEl.empty();
    }
}
class SettingTab extends obsidian.PluginSettingTab {
    constructor(app, plugin) {
        super(app, plugin);
        this.plugin = plugin;
    }
    display() {
        let { containerEl } = this;
        containerEl.empty();
        containerEl.createEl('h2', { text: 'Settings for Scales and Chords' });
        new obsidian.Setting(containerEl)
            .setName('instrument')
            .setDesc('musical instrument to render')
            .addText(text => text
            .setPlaceholder('Enter instrument')
            .setValue(this.plugin.settings.instrument)
            .onChange((value) => __awaiter(this, void 0, void 0, function* () {
            this.plugin.settings.instrument = value;
            yield this.plugin.saveSettings();
        })));
    }
}
function append_chord_image(el, chord, instrument) {
    postData("https://www.scales-chords.com/api/scapi.1.3.php", {
        'id': 'scapiobjid1',
        'class': 'scales_chords_api',
        'chord': chord,
        'instrument': instrument
    })
        .then(res => res.text())
        .then(text => {
        let arr = text.split("###RAWR###");
        let inner = document.createElement("div");
        inner.innerHTML = arr[arr.length - 1];
        el.appendChild(inner);
    });
}
function postData(url = '', data = {}) {
    // Default options are marked with *
    const response = fetch(url, {
        method: 'POST',
        mode: 'cors',
        cache: 'no-cache',
        credentials: 'same-origin',
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
        },
        redirect: 'follow',
        referrerPolicy: 'no-referrer',
        body: serialize(data) // body data type must match "Content-Type" header
    });
    return response;
}
function serialize(obj) {
    var str = [];
    for (var p in obj)
        str.push(encodeURIComponent(p) + "=" + encodeURIComponent(obj[p]));
    return str.join("&");
}

module.exports = ScalesChordsPlugin;


/* nosourcemap */